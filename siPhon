#!/usr/bin/python3

##############################################################################
### siPhon: A tool for access to data in iPods or other poorly-formed sets of
### audio files.  It tries to make no assumptions about the arrangement of the
### information.  You can use it on your files recovered from a formatted drive
### if you like, and as long as they were tagged, it will probably make some
### sense of them.
##################################################
#### Chris Smith, 2022
##################################################


import os, sys, re
import shutil
import argparse

#Persistent index
import pickle
#ID3 tags -- does this do aac?
import mutagen
#File recognition
import magic
#Progress bar
from tqdm import tqdm

ap = argparse.ArgumentParser()
#Setting these to placeholder values in the main parser ensures that they're
# always defined, so we chan check against None to see whether they've been used.
ap.set_defaults(song=None,album=None,artist=None,cmd=None) 
ap.add_argument('-i','--base',required=True,help="Location of iPod")
ap.add_argument('--db',help="Location of database")
sp = ap.add_subparsers(title="Commands",help="Specify <command> -h for help on a command.")
p_scan = sp.add_parser('scan',help="Scan device for music and write database.",aliases=['init','index'])
p_scan.set_defaults(cmd='scan')
p_clean = sp.add_parser('clean',help="Remove database generated by 'scan'.")
p_clean.set_defaults(cmd='clean')
p_artists = sp.add_parser('artists',help="List artists in database.",aliases=['artist','art'])
p_artists.set_defaults(cmd='artists')
p_albums = sp.add_parser('albums',help="List albums in database.",aliases=['album','alb'])
p_albums.set_defaults(cmd='albums')
p_list = sp.add_parser('list',help="List music in database.", aliases=['dir','ls'])
p_list.add_argument('-a','--artist',help="Filter by artist")
p_list.add_argument('-A','--album',help="Filter by album")
p_list.add_argument('-s','-t','--song','--track',help="Filter by track name")
p_list.set_defaults(cmd='list')
p_get = sp.add_parser('get',help="Copy music from the device.",aliases=['extract','cp','copy'])
p_get.add_argument('-a','--artist',help="Filter by artist")
p_get.add_argument('-A','--album',help="Filter by album")
p_get.add_argument('-s','-t','--song','--track',help="Filter by track name")
p_get.add_argument('-d','-o','--dest','--out',required=True,help="Base directory for output.")
p_get.set_defaults(cmd='get')

args = ap.parse_args()

def writedb():
	rv = True
	try:
		if not os.path.exists(dbDir):
			os.mkdir(dbDir)
		albF = open(dbAlbums,'wb')
		artF = open(dbArtists,'wb')
		songF = open(dbSongs,'wb')
		fileF = open(dbFiles,'wb')
		pickle.dump(Albums,albF)
		pickle.dump(Artists,artF)
		pickle.dump(Songs,songF)
		pickle.dump(Files,fileF)
		albF.close()
		artF.close()
		songF.close()
		fileF.close()
	except Exception as e:
		print("Can't write database.")
		rv = False
	return rv

def readdb():
	global Albums, Artists, Songs, Files
	rv = True
	try:
		albF = open(dbAlbums,'rb')
		artF = open(dbArtists,'rb')
		songF = open(dbSongs,'rb')
		fileF = open(dbFiles,'rb')
		Albums = pickle.load(albF)
		Artists = pickle.load(artF)
		Songs = pickle.load(songF)
		Files = pickle.load(fileF)
		albF.close()
		artF.close()
		songF.close()
		fileF.close()
	except Exception as e:
		print("Can't read database.  Try scan first.")
		rv = False
	return rv

def rmdb():
	rv = True
	if args.db:
		print("Won't clean a database specified on the command-line. Delete it manually.")
		return False
	try:
		os.unlink(dbAlbums)
		os.unlink(dbArtists)
		os.unlink(dbSongs)
		os.unlink(dbFiles)
		os.rmdir(dbDir)
	except Exception as e:
		rv = False
	return rv

#Clean up tags
def tsanitize(st):
	st = str(st)
	st = re.sub(r"^\['",'',st)
	st = re.sub(r'^\["','',st)
	st = re.sub(r"'\]$",'',st)
	st = re.sub(r'"\]$','',st)
	st = re.sub(r"^\s+",'',st)
	st = re.sub(r"\s+$",'',st)
	return st

#Clean up filenames
def fsanitize(st):
	st = re.sub(r'[^a-zA-Z0-9 \-_.,]','',st)
	st = re.sub(r'\s+$','',st)
	st = re.sub(r'^\s+','',st)
	return st

def scan():
	os.chdir(args.base)
	for base, dirs, files in os.walk("."):
		for file in (progress := tqdm(files)):
			m = ""
			fn = os.path.join(base,file)
			progress.set_description(fn)
			try:
				m = magic.from_file(fn)
			except Exception as e:
				pass
			if re.search('audio',m,re.IGNORECASE):
				if re.search('alac',m,re.IGNORECASE) or re.search('aac',m,re.IGNORECASE):
					fmt = 'm4a'
				else: 
					#Probably
					fmt = 'mp3'
				try:
					tags = mutagen.File(fn)
				except:
					pass
				if tags:
					album = "Unknown Album"
					artist = "Unknown"
					trnum = ""
					trnam = "Untitled"
					if 'TRCK' in tags:
						trnum = tags['TRCK']
					else:
						if 'trkn' in tags:
							trnum = str(tags['trkn'])	
					if 'TIT2' in tags:
						trnam = str(tags['TIT2'])
					else:
						if '©nam' in tags:
							trnam = str(tags['©nam'])
					if 'TALB' in tags:
						album = str(tags['TALB'])
					else:
						if '©alb' in tags:
							album = str(tags['©alb'])
					if 'TPE1' in tags:
						artist = str(tags['TPE1'])
					else:
						if '©ART' in tags:
							artist = str(tags['©ART'])

					artist = tsanitize(artist)
					album = tsanitize(album)
					trnam = tsanitize(trnam)
					trnum = tsanitize(trnum)

					#if (album == "Unknown Album"):
					#	print("NO ALBUM: ")
					#	print(tags)
					#Fix the stupid 01/08-type track numbers.
					trnum = re.sub('.*?([0-9]+).*',r"\1",trnum)

					if not trnam in Songs:
						Songs[trnam] = []
					if not artist in Artists:
						Artists[artist] = []
					if not album in Albums:
						Albums[album] = []
					if not file in Files:
						Files[fn] = []
					Songs[trnam].append(fn)
					Albums[album].append(fn)
					Artists[artist].append(fn)
					Files[fn] = { 'artist' : artist, 'album' : album, 'trnum' : trnum, 'trnam' : trnam, 'fmt' : fmt }
	writedb()

def find(artist=args.artist,album=args.album,trnam=args.song):
	flist = Files
	if trnam and Songs.has_key(trnam):
		if not trnam in Songs:
			print("No songs matching " + trnam)
			return {}
		flist = [ file for file in flist if file in Songs[trnam] ]
	if album:
		if not album in Albums:
			print("No albums matching " + album)
			return ()
		flist = [ file for file in flist if file in Albums[album] ]
	if artist:
		if not artist in Artists:
			print("No artists matching " + artist)
			return {}
		flist = [ file for file in flist if file in Artists[artist] ]
	return flist

def ls():
	if not readdb():
		return False
	for file in find():
		print("Artist: " + Files[file]['artist'] + " / Album: " + Files[file]['album'])
		print("Name: " + Files[file]['trnam'] + " / File: " + file)
		print("--------")
def lsartists():
	if not readdb():
		return False
	for a in Artists.keys():
		print(a)
def lsalbums():
	if not readdb():
		return False
	for a in Albums.keys():
			print(a)
def get():
	if not readdb():
		return False
	working = os.getcwd()

	if args.dest.startswith("/"):
 		destdir = args.dest
	else:
		destdir = os.path.join(working,args.dest)

	os.chdir(args.base)
	for source in (progress := tqdm(find())): 
		f = Files[source]
		ddir = os.path.join(destdir,fsanitize(f['artist']),fsanitize(f['album']))
		dname = ""
		if (f['trnum'] != ""):
			dname = f['trnum'] + ". "
		dname = dname + f['trnam'] + "." + f['fmt']
		dname = fsanitize(dname)
        
		progress.set_description(os.path.join(ddir,dname))
		#Use os.mkdirs to make all the directories at once.
		try:
			os.makedirs(ddir, exist_ok=True)
		except Exception as e:
			print("Can't create " + ddir)
		try:
			shutil.copyfile(source,os.path.join(ddir,dname))
		except Exception as e:
			print("Can't create " + os.path.join(ddir,dname))


if os.path.isdir(args.base):
	if args.db:
		dbDir       = args.db
	else:
		dbDir= os.path.join(args.base,"siPhon-db")
	dbArtists       = os.path.join(dbDir,"artists.db")
	Artists         = {}
	dbAlbums        = os.path.join(dbDir,"albums.db")
	Albums          = {}
	dbSongs         = os.path.join(dbDir,"songs.db")
	Songs           = {}
	dbFiles         = os.path.join(dbDir,"files.db")
	Files           = {}

	if not args.cmd:
		print("Please specify a command.")
	else:
		if args.cmd == 'scan':
			scan()
		if args.cmd == 'clean':
			rmdb()
		if args.cmd == 'list':
			ls()
		if args.cmd == 'get':
			get()
		if args.cmd == 'artists':
			lsartists()
		if args.cmd == 'albums':
			lsalbums()

else:
	print("Root of collection not available: " + args.base)


